{
  "script": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// adapters/adapter.js\nvar require_adapter = __commonJS({\n  \"adapters/adapter.js\"(exports) {\n    var Adapter = class {\n      /**\n       * Constructs an instance of Adapter.\n       * @param {object} main - The main context object which should contain a configuration object.\n       */\n      constructor(main) {\n        this.main = main;\n        Object.assign(this, main.config);\n      }\n    };\n    exports.Adapter = Adapter;\n  }\n});\n\n// adapters/transformers.js\nvar require_transformers = __commonJS({\n  \"adapters/transformers.js\"(exports) {\n    var { Adapter } = require_adapter();\n    var TransformersAdapter = class extends Adapter {\n      async init() {\n        const { env, pipeline, AutoTokenizer } = await import(\"@xenova/transformers\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true, max_length: this.max_tokens });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n      }\n      async embed_batch(items) {\n        items = items.filter((item) => {\n          var _a;\n          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;\n        });\n        if (!(items == null ? void 0 : items.length))\n          return [];\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = await Promise.all(items.map(async (item, i) => {\n          if (tokens[i] < this.max_tokens)\n            return item.embed_input;\n          let token_ct = tokens[i];\n          let truncated_input = item.embed_input;\n          while (token_ct > this.max_tokens) {\n            const pct = this.max_tokens / token_ct;\n            const max_chars = Math.floor(truncated_input.length * pct * 0.9);\n            truncated_input = truncated_input.substring(0, max_chars) + \"...\";\n            token_ct = await this.count_tokens(truncated_input);\n          }\n          tokens[i] = token_ct;\n          return truncated_input;\n        }));\n        try {\n          const resp2 = await this.model(embed_input, { pooling: \"mean\", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp2[i].data);\n            item.tokens = tokens[i];\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log(\"Error embedding batch. Trying one at a time...\");\n        }\n        const resp = await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          if (!vec) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(\"Vec: \", vec);\n            console.log(\"Error: \", error);\n            console.log(\"Tokens: \", tokens2);\n            console.log(\"No vec returned\");\n            item.error = \"No vec returned\";\n            return item;\n          }\n          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);\n          item.tokens = tokens2;\n          return item;\n        }));\n        return resp;\n      }\n      async embed(input) {\n        const output = { embed_input: input };\n        if (!input)\n          return { ...output, error: \"No input text.\" };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: \"Input too short.\" };\n          if (output.tokens < this.max_tokens) {\n            const embedding = await this.model(input, { pooling: \"mean\", normalize: true });\n            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);\n          } else {\n            const pct = this.max_tokens / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + \"...\";\n            output.truncated = true;\n            console.log(\"Input too long. Truncating to \", input.length, \" characters.\");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n      async unload() {\n        await this.model.dispose();\n      }\n    };\n    exports.TransformersAdapter = TransformersAdapter;\n  }\n});\n\n// transformers_iframe.js\nvar require_transformers_iframe = __commonJS({\n  \"transformers_iframe.js\"(exports) {\n    var { TransformersAdapter } = require_transformers();\n    var TransformersIframeConnector = class _TransformersIframeConnector extends TransformersAdapter {\n      constructor(model_config, window2) {\n        super({ config: model_config });\n        this.model = null;\n        this.running_init = false;\n        this.window = window2;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      static async create(model_config, window2) {\n        const connector = new _TransformersIframeConnector(model_config, window2);\n        await connector.init();\n        return connector;\n      }\n      async init() {\n        if (this.model)\n          return console.log(\"Smart Local Model already loaded\");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log(\"Loading Smart Local Model\");\n        const { pipeline, env, AutoTokenizer } = await import(\"https://cdn.jsdelivr.net/npm/@xenova/transformers@latest\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed(\"test\"));\n        this.window.postMessage({ type: \"model_loaded\", data: true }, \"*\");\n        this.window.addEventListener(\"message\", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == \"smart_embed\")\n          this.embed_handler(event.data);\n        if (event.data.type == \"smart_embed_token_ct\")\n          this.count_tokens_handler(event.data.embed_input);\n        if (event.data.type == \"smart_embed_unload\")\n          await this.unload();\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: \"smart_embed_resp\",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = \"smart_embed_resp\";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: \"smart_embed_token_ct\",\n          text: \"count:\" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, \"*\");\n      }\n      async unload() {\n        var _a;\n        try {\n          await ((_a = this.model) == null ? void 0 : _a.dispose());\n        } catch (error) {\n          console.warn(\"Failed to unload SmartEmbedTransformersWebAdapter:\", error);\n        }\n        this.window.postMessage({ type: \"smart_embed_unloaded\", unloaded: true }, \"*\");\n      }\n    };\n    exports.TransformersIframeConnector = TransformersIframeConnector;\n  }\n});\n\n// smart_embed_web.js\nwindow.addEventListener(\"message\", init);\nasync function init(event) {\n  if (event.data.type === \"init\") {\n    window.removeEventListener(\"message\", init);\n    const model_config = event.data.model_config;\n    console.log(model_config);\n    const { TransformersIframeConnector } = await Promise.resolve().then(() => __toESM(require_transformers_iframe()));\n    const model = await TransformersIframeConnector.create(model_config, window);\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiYWRhcHRlcnMvYWRhcHRlci5qcyIsICJhZGFwdGVycy90cmFuc2Zvcm1lcnMuanMiLCAidHJhbnNmb3JtZXJzX2lmcmFtZS5qcyIsICJzbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogUmVwcmVzZW50cyBhIGdlbmVyaWMgYWRhcHRlciBjbGFzcyB0aGF0IGluaXRpYWxpemVzIHdpdGggYSBtYWluIGNvbnRleHQgYW5kIGNvcGllcyBpdHMgY29uZmlndXJhdGlvbi5cbiAqL1xuY2xhc3MgQWRhcHRlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIEFkYXB0ZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluIC0gVGhlIG1haW4gY29udGV4dCBvYmplY3Qgd2hpY2ggc2hvdWxkIGNvbnRhaW4gYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1haW4pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbWFpbiBjb250ZXh0IG9iamVjdCBmcm9tIHdoaWNoIGNvbmZpZ3VyYXRpb24gaXMgZGVyaXZlZC5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMubWFpbiA9IG1haW47XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBmcm9tIHRoZSBtYWluIG9iamVjdCdzIGNvbmZpZyBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgbWFpbi5jb25maWcpOyAvLyBDb3B5IGNvbmZpZyB0byB0aGlzXG4gIH1cbn1cblxuLy8gRXhwb3J0IHRoZSBBZGFwdGVyIGNsYXNzIHRvIGJlIGF2YWlsYWJsZSBmb3Igb3RoZXIgbW9kdWxlcy5cbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG4iLCAiY29uc3QgeyBBZGFwdGVyIH0gPSByZXF1aXJlKFwiLi9hZGFwdGVyXCIpO1xuXG5jbGFzcyBUcmFuc2Zvcm1lcnNBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgY29uc3QgeyBlbnYsIHBpcGVsaW5lLCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ0B4ZW5vdmEvdHJhbnNmb3JtZXJzJyk7XG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUsIG1heF9sZW5ndGg6IHRoaXMubWF4X3Rva2VucyB9KTtcbiAgICAvLyB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IGZhbHNlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgfVxuICBhc3luYyBlbWJlZF9iYXRjaChpdGVtcykge1xuICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5lbWJlZF9pbnB1dD8ubGVuZ3RoID4gMCk7IC8vIHJlbW92ZSBpdGVtcyB3aXRoIGVtcHR5IGVtYmVkX2lucHV0IChjYXVzZXMgLnNwbGl0KCkgZXJyb3IpXG4gICAgaWYoIWl0ZW1zPy5sZW5ndGgpIHJldHVybiBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNvdW50X3Rva2VucyhpdGVtLmVtYmVkX2lucHV0KSkpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAodG9rZW5zW2ldIDwgdGhpcy5tYXhfdG9rZW5zKSByZXR1cm4gaXRlbS5lbWJlZF9pbnB1dDtcbiAgICAgIGxldCB0b2tlbl9jdCA9IHRva2Vuc1tpXTtcbiAgICAgIGxldCB0cnVuY2F0ZWRfaW5wdXQgPSBpdGVtLmVtYmVkX2lucHV0O1xuICAgICAgd2hpbGUgKHRva2VuX2N0ID4gdGhpcy5tYXhfdG9rZW5zKSB7XG4gICAgICAgIGNvbnN0IHBjdCA9IHRoaXMubWF4X3Rva2VucyAvIHRva2VuX2N0OyAvLyBnZXQgcGN0IG9mIGlucHV0IHRvIGtlZXBcbiAgICAgICAgY29uc3QgbWF4X2NoYXJzID0gTWF0aC5mbG9vcih0cnVuY2F0ZWRfaW5wdXQubGVuZ3RoICogcGN0ICogMC45MCk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyAxMCUgZm9yIHNhZmV0eSlcbiAgICAgICAgdHJ1bmNhdGVkX2lucHV0ID0gdHJ1bmNhdGVkX2lucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgdG9rZW5fY3QgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2Vucyh0cnVuY2F0ZWRfaW5wdXQpO1xuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coXCJJbnB1dCB0b28gbG9uZy4gVHJ1bmNhdGluZyB0byBcIiwgdHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vuc1tpXSwgXCIgLT4gXCIsIHRva2VuX2N0KTtcbiAgICAgIHRva2Vuc1tpXSA9IHRva2VuX2N0O1xuICAgICAgcmV0dXJuIHRydW5jYXRlZF9pbnB1dDtcbiAgICB9KSk7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XG4gICAgdHJ5e1xuICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMubW9kZWwoZW1iZWRfaW5wdXQsIHsgcG9vbGluZzogJ21lYW4nLCBub3JtYWxpemU6IHRydWUgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaXRlbS52ZWMgPSBBcnJheS5mcm9tKHJlc3BbaV0uZGF0YSk7XG4gICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zW2ldO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pO1xuICAgIH1jYXRjaChlcnIpe1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGJhdGNoLiBUcnlpbmcgb25lIGF0IGEgdGltZS4uLlwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyBpdGVtID0+IHtcbiAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmVtYmVkKGl0ZW0uZW1iZWRfaW5wdXQpO1xuICAgICAgaWYoZXJyb3Ipe1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcIiwgaXRlbS5rZXkpO1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIGl0ZW0uZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpZighdmVjKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJWZWM6IFwiLCB2ZWMpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiwgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlRva2VuczogXCIsIHRva2Vucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm8gdmVjIHJldHVybmVkXCIpO1xuICAgICAgICBpdGVtLmVycm9yID0gXCJObyB2ZWMgcmV0dXJuZWRcIjtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpdGVtLnZlYyA9IHZlYy5tYXAodmFsID0+IE1hdGgucm91bmQodmFsICogMTAwMDAwMDAwKSAvIDEwMDAwMDAwMCk7IC8vIHJlZHVjZSBwcmVjaXNpb24gdG8gOCBkZWNpbWFsIHBsYWNlcyByZWY6IGh0dHBzOi8vd2ZoYnJpYW4uY29tL3ZlY3Rvci1kaW1lbnNpb24tcHJlY2lzaW9uLWVmZmVjdC1vbi1jb3NpbmUtc2ltaWxhcml0eS9cbiAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zO1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSkpO1xuICAgIHJldHVybiByZXNwO1xuICB9XG4gIGFzeW5jIGVtYmVkKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0geyBlbWJlZF9pbnB1dDogaW5wdXQgfTtcbiAgICBpZiAoIWlucHV0KSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIk5vIGlucHV0IHRleHQuXCIgfTtcbiAgICBpZiAoIXRoaXMubW9kZWwpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIklucHV0IHRvbyBzaG9ydC5cIiB9O1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCB0aGlzLm1heF90b2tlbnMpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpLm1hcCh2YWwgPT4gTWF0aC5yb3VuZCh2YWwgKiAxMDAwMDAwMDApIC8gMTAwMDAwMDAwKTsgLy8gcmVkdWNlIHByZWNpc2lvbiB0byA4IGRlY2ltYWwgcGxhY2VzIHJlZjogaHR0cHM6Ly93Zmhicmlhbi5jb20vdmVjdG9yLWRpbWVuc2lvbi1wcmVjaXNpb24tZWZmZWN0LW9uLWNvc2luZS1zaW1pbGFyaXR5L1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5tYXhfdG9rZW5zIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxuXG4gIGFzeW5jIHVubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLm1vZGVsLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG5leHBvcnRzLlRyYW5zZm9ybWVyc0FkYXB0ZXIgPSBUcmFuc2Zvcm1lcnNBZGFwdGVyOyIsICJjb25zdCB7IFRyYW5zZm9ybWVyc0FkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvdHJhbnNmb3JtZXJzJyk7XG5cbi8vIENPTk5FQ1RPUiBGT1IgT0JTSURJQU5cbmNsYXNzIFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3RvciBleHRlbmRzIFRyYW5zZm9ybWVyc0FkYXB0ZXIge1xuICBjb25zdHJ1Y3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdykge1xuICAgIHN1cGVyKHtjb25maWc6IG1vZGVsX2NvbmZpZ30pOyAvLyBhc3NpZ25zIGNvbmZpZyB0byB0aGlzIGluIEFkYXB0ZXJcbiAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIC8vIHN0YXRzXG4gICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMudG9rZW5zID0gMDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKG1vZGVsX2NvbmZpZywgd2luZG93KSB7XG4gICAgY29uc3QgY29ubmVjdG9yID0gbmV3IFRyYW5zZm9ybWVyc0lmcmFtZUNvbm5lY3Rvcihtb2RlbF9jb25maWcsIHdpbmRvdyk7XG4gICAgYXdhaXQgY29ubmVjdG9yLmluaXQoKTtcbiAgICByZXR1cm4gY29ubmVjdG9yO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgaWYgKHRoaXMubW9kZWwpIHJldHVybiBjb25zb2xlLmxvZyhcIlNtYXJ0IExvY2FsIE1vZGVsIGFscmVhZHkgbG9hZGVkXCIpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmdfaW5pdCkgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMDApKTtcbiAgICBpZiAoIXRoaXMubW9kZWwgJiYgIXRoaXMucnVubmluZ19pbml0KSB0aGlzLnJ1bm5pbmdfaW5pdCA9IHRydWU7XG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIFNtYXJ0IExvY2FsIE1vZGVsXCIpO1xuICAgIC8vIGNvbnN0IHsgcGlwZWxpbmUsIGVudiwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQDIuMTMuMCcpO1xuICAgIGNvbnN0IHsgcGlwZWxpbmUsIGVudiwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL0B4ZW5vdmEvdHJhbnNmb3JtZXJzQGxhdGVzdCcpO1xuICAgIGVudi5hbGxvd0xvY2FsTW9kZWxzID0gZmFsc2U7XG4gICAgdGhpcy5tb2RlbCA9IGF3YWl0IHBpcGVsaW5lKCdmZWF0dXJlLWV4dHJhY3Rpb24nLCB0aGlzLm1vZGVsX25hbWUsIHsgcXVhbnRpemVkOiB0cnVlIH0pO1xuICAgIHRoaXMudG9rZW5pemVyID0gYXdhaXQgQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQodGhpcy5tb2RlbF9uYW1lKTtcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xuICAgIHRoaXMud2luZG93LnRva2VuaXplciA9IHRoaXMudG9rZW5pemVyO1xuICAgIGNvbnNvbGUubG9nKGF3YWl0IHRoaXMuZW1iZWQoXCJ0ZXN0XCIpKTtcbiAgICAvLyB0aGlzLndpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcIm1vZGVsX2xvYWRlZFwiLCBkYXRhOiB0cnVlIH0sIFwiKlwiKTsgLy8gcG9zdCBtZXNzYWdlIHRvIHBhcmVudCB0aGF0IG1vZGVsIGlzIGxvYWRlZFxuICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJtb2RlbF9sb2FkZWRcIiwgZGF0YTogdHJ1ZSB9LCBcIipcIik7IC8vIHBvc3QgbWVzc2FnZSB0byBwYXJlbnQgdGhhdCBtb2RlbCBpcyBsb2FkZWRcbiAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZV9pcGMuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIGhhbmRsZV9pcGMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRcIikgdGhpcy5lbWJlZF9oYW5kbGVyKGV2ZW50LmRhdGEpO1xuICAgIC8vIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZF9iYXRjaFwiKSB0aGlzLmVtYmVkX2JhdGNoX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XCIpIHRoaXMuY291bnRfdG9rZW5zX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkX3VubG9hZFwiKSBhd2FpdCB0aGlzLnVubG9hZCgpO1xuICB9XG4gIGFzeW5jIGVtYmVkX2hhbmRsZXIoZXZlbnRfZGF0YSkge1xuICAgIGNvbnN0IHsgZW1iZWRfaW5wdXQsIGhhbmRsZXJfaWQgfSA9IGV2ZW50X2RhdGE7XG4gICAgLy8gY29uc29sZS5sb2coZW1iZWRfaW5wdXQpO1xuICAgIGlmKCF0aGlzLnRpbWVzdGFtcCkgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmKEFycmF5LmlzQXJyYXkoZW1iZWRfaW5wdXQpKSB7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5lbWJlZF9iYXRjaChlbWJlZF9pbnB1dCk7XG4gICAgICBjb25zdCBzZW5kX2RhdGEgPSB7XG4gICAgICAgIHR5cGU6IFwic21hcnRfZW1iZWRfcmVzcFwiLFxuICAgICAgICBoYW5kbGVyX2lkLFxuICAgICAgICBkYXRhOiByZXNwLFxuICAgICAgfTtcbiAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xuICAgICAgdGhpcy50b2tlbnMgKz0gcmVzcC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4gYWNjICsgaXRlbS50b2tlbnMsIDApO1xuICAgICAgdGhpcy5lbWJlZF9jdCArPSByZXNwLmxlbmd0aDtcbiAgICB9ZWxzZXtcbiAgICAgIGlmICghdGhpcy50aW1lc3RhbXApIHRoaXMudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IGF3YWl0IHRoaXMuZW1iZWQoZW1iZWRfaW5wdXQpO1xuICAgICAgc2VuZF9kYXRhLnR5cGUgPSBcInNtYXJ0X2VtYmVkX3Jlc3BcIjtcbiAgICAgIGlmIChoYW5kbGVyX2lkKSBzZW5kX2RhdGEuaGFuZGxlcl9pZCA9IGhhbmRsZXJfaWQ7XG4gICAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgICAgIHRoaXMudG9rZW5zICs9IHNlbmRfZGF0YS50b2tlbnM7XG4gICAgICB0aGlzLmVtYmVkX2N0Kys7XG4gICAgfVxuICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXAgPiAxMDAwMCkge1xuICAgICAgY29uc29sZS5sb2coYEVtYmVkZGVkOiAke3RoaXMuZW1iZWRfY3R9IGlucHV0cyAoJHt0aGlzLnRva2Vuc30gdG9rZW5zLCAkeyh0aGlzLnRva2VucyAvICgoRGF0ZS5ub3coKSAtIHRoaXMudGltZXN0YW1wKSAvIDEwMDApKS50b0ZpeGVkKDApfSB0b2tlbnMvc2VjKWApO1xuICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgICAgdGhpcy50b2tlbnMgPSAwO1xuICAgICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvdW50X3Rva2Vuc19oYW5kbGVyKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcbiAgICAgIHR5cGU6IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIixcbiAgICAgIHRleHQ6IFwiY291bnQ6XCIgKyBpbnB1dCxcbiAgICAgIGNvdW50OiBvdXRwdXRcbiAgICB9O1xuICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xuICB9XG4gIGFzeW5jIHVubG9hZCgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5tb2RlbD8uZGlzcG9zZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gdW5sb2FkIFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJBZGFwdGVyOlwiLCBlcnJvcik7XG4gICAgfVxuICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJzbWFydF9lbWJlZF91bmxvYWRlZFwiLCB1bmxvYWRlZDogdHJ1ZSB9LCBcIipcIik7XG4gIH1cbn1cbmV4cG9ydHMuVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yID0gVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yO1xuXG4iLCAid2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0KTsgLy8gbGlzdGVuIGZvciBpbml0IG1lc3NhZ2VcbmFzeW5jIGZ1bmN0aW9uIGluaXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ2luaXQnKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0KTsgLy8gcmVtb3ZlIHRoaXMgZXZlbnQgbGlzdGVuZXJcbiAgICBjb25zdCBtb2RlbF9jb25maWcgPSBldmVudC5kYXRhLm1vZGVsX2NvbmZpZztcbiAgICBjb25zb2xlLmxvZyhtb2RlbF9jb25maWcpO1xuICAgIGNvbnN0IHsgVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yIH0gPSBhd2FpdCBpbXBvcnQoJy4vdHJhbnNmb3JtZXJzX2lmcmFtZS5qcycpO1xuICAgIGNvbnN0IG1vZGVsID0gYXdhaXQgVHJhbnNmb3JtZXJzSWZyYW1lQ29ubmVjdG9yLmNyZWF0ZShtb2RlbF9jb25maWcsIHdpbmRvdyk7XG4gICAgd2luZG93Lm1vZGVsID0gbW9kZWw7XG4gIH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBR0EsUUFBTSxVQUFOLE1BQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS1osWUFBWSxNQUFNO0FBS2hCLGFBQUssT0FBTztBQUtaLGVBQU8sT0FBTyxNQUFNLEtBQUssTUFBTTtBQUFBLE1BQ2pDO0FBQUEsSUFDRjtBQUdBLFlBQVEsVUFBVTtBQUFBO0FBQUE7OztBQ3ZCbEI7QUFBQTtBQUFBLFFBQU0sRUFBRSxRQUFRLElBQUk7QUFFcEIsUUFBTSxzQkFBTixjQUFrQyxRQUFRO0FBQUEsTUFDeEMsTUFBTSxPQUFPO0FBQ1gsY0FBTSxFQUFFLEtBQUssVUFBVSxjQUFjLElBQUksTUFBTSxPQUFPLHNCQUFzQjtBQUM1RSxZQUFJLG1CQUFtQjtBQUN2QixhQUFLLFFBQVEsTUFBTSxTQUFTLHNCQUFzQixLQUFLLFlBQVksRUFBRSxXQUFXLE1BQU0sWUFBWSxLQUFLLFdBQVcsQ0FBQztBQUVuSCxhQUFLLFlBQVksTUFBTSxjQUFjLGdCQUFnQixLQUFLLFVBQVU7QUFBQSxNQUN0RTtBQUFBLE1BQ0EsTUFBTSxZQUFZLE9BQU87QUFDdkIsZ0JBQVEsTUFBTSxPQUFPLFVBQUs7QUFYOUI7QUFXaUMsNkJBQUssZ0JBQUwsbUJBQWtCLFVBQVM7QUFBQSxTQUFDO0FBQ3pELFlBQUcsRUFBQywrQkFBTztBQUFRLGlCQUFPLENBQUM7QUFDM0IsY0FBTSxTQUFTLE1BQU0sUUFBUSxJQUFJLE1BQU0sSUFBSSxVQUFRLEtB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WTtBQUFBLFFBQ3BCLFNBQVMsT0FBTztBQUNkLGtCQUFRLEtBQUssc0RBQXNELEtBQUs7QUFBQSxRQUMxRTtBQUNBLGFBQUssT0FBTyxZQUFZLEVBQUUsTUFBTSx3QkFBd0IsVUFBVSxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQy9FO0FBQUEsSUFDRjtBQUNBLFlBQVEsOEJBQThCO0FBQUE7QUFBQTs7O0FDMUZ0QyxPQUFPLGlCQUFpQixXQUFXLElBQUk7QUFDdkMsZUFBZSxLQUFLLE9BQU87QUFDekIsTUFBSSxNQUFNLEtBQUssU0FBUyxRQUFRO0FBQzlCLFdBQU8sb0JBQW9CLFdBQVcsSUFBSTtBQUMxQyxVQUFNLGVBQWUsTUFBTSxLQUFLO0FBQ2hDLFlBQVEsSUFBSSxZQUFZO0FBQ3hCLFVBQU0sRUFBRSw0QkFBNEIsSUFBSSxNQUFNO0FBQzlDLFVBQU0sUUFBUSxNQUFNLDRCQUE0QixPQUFPLGNBQWMsTUFBTTtBQUMzRSxXQUFPLFFBQVE7QUFBQSxFQUNqQjtBQUNGOyIsCiAgIm5hbWVzIjogWyJyZXNwIiwgInRva2VucyIsICJ3aW5kb3ciXQp9Cg==\n"
}